# 시간 복잡도

* **알고리즘의 수행 시간을 의미**

* 좋은 알고리즘 : nput을 넣은 후 Ouptut이 나오는 시간이 짧은 알고리즘



## 알고리즘 소요 시간 측정하기

* 알고리즘 내부에서 기본연산이 몇번 일어나는지 살펴보기
* 기본연산의 총 횟수 == 알고리즘의 소요 시간
* 입력에 개수에 따라 시간이 달라진다.

시간 복잡도가 높다 => 느린 알고리즘

시간 복잡도가 낮다 => 빠른 알고리즘

# 빅오 표기법

* 입력 n이 무한대로 커진다고 가정사고 시간 복잡도를 간단하게 표시하는 것. ( 최고차항만 남기고 계수와 상수를 제거한다.)
* 아래로 갈수록 시간 복잡도 높아짐(느린 알고리즘)

| O(1)     | 단순 산술 계산(덧셈,뺄셈,곱셈,나눗셈)                      |
| -------- | ---------------------------------------------------------- |
| O(N)     | 크기 N인 리스트를 순회 , **1중 for문**                     |
| O(logN)  | 크기(N)인 리스트를 반절씩 순회/탐색, **이진탐색,분할정복** |
| O(NlogN) | 크기 N인 리스트를 반절씩 탐색*순회                         |
| O(N^2)   | 크기 M,N인 2중 리스트를 순회, **2중 for문**                |
| O(N^3)   | 3중 리스트를 순회, **3중 for문**                           |
| O(2^N)   | 크기 N 집합의 부분 집합                                    |
| O(N!)    | 크기 N 리스트의 순열                                       |

* for 문이라고해서 반드시 시간 복잡도가 O(N)인 것은 아님
  * for문 안에 O(n)의 내장함수를 썼다면 이중for문과 다를게 없다.

## 배열

**여러 데이터들이 연속된 메모리 공간의 저장되어 있는 자료구조**

* 인덱스를 통해 데이터에 빠르게 접근
* 배일의 길이는 변경 불가능 => 길이를 변경하고 싶다면 새로 생성
* 데이터 타입은 고정



## 연결리스트

**데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조**

* 맨 처음 노드부터 순차적으로 탐색
* 연결리스트의 길이 자유롭게 변경 가능 => 삽입, 삭제가 편리
* 다양한 데이터 타입 저장
* 데이터가 메모리에 연속적으로 저장되지 않음

**파이썬의 리스트 배열과 연결리스트의 장점을 같이 가지고 있다**

* 파이썬 리스트의 메서드
  * 1).append(원소) : 맨 끝에  원소 삽입 => 복잡도 : O(1)
  * 2).pop(인덱스) : 특정 인덱스에 있는 원소 삭제 및 변환 => 복잡도 : O(1)  (리턴값이 존재한다.)
  * 3).count(원소) : 리스트에서 해당 원소의 갯수 반환 => 복잡도 : O(N)
  * 4).index(원소) : 리스트에서 처음으로 원소가 등장하는 인덱스 반환 => O(N)
  * 5).sort() : 리스트 오름차순 정렬 reverse = True 옵션을 통해 내림차순으로 정렬 가능 => 복잡도 : O(N)보다 좀 더 느리다
  * 6).reverse() : 리스트 원소들 순서를 거꾸로 뒤집기 => 복잡도 : O(N)
